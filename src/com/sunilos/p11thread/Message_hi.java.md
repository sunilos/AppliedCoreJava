
```java
package com.sunilos.p11thread;

/**
 * संदेश ऑब्जेक्ट WaiterThread और NotifierThread के बीच साझा किया गया है।
 * 
 * WaiterThread संदेश ऑब्जेक्ट पर एक लॉक (मॉनिटर) प्राप्त करता है और wait() मेथड को कॉल करके लॉक को रिलीज़ करता है। 
 * जब एक थ्रेड इस मेथड को कॉल करता है, तो यह कार्यशीलता को रोकता है और लॉक को छोड़ देता है, 
 * एक सूचना का इंतज़ार करता है ताकि वह फिर से शुरू कर सके।
 * 
 * दूसरी ओर, NotifierThread एक सूचना भेजेगा ताकि WaiterThread को जगाया जा सके। 
 * यह notify() मेथड (एक प्रतीक्षारत थ्रेड को जगाने के लिए) या notifyAll() मेथड (सभी प्रतीक्षारत थ्रेड्स को जगाने के लिए) 
 * को कॉल करके किया जाता है।
 * 
 * @संस्करण 1.0
 * @तारीख 16 नवम्बर 2014
 * @लेखक सुनिल साहू
 * @कॉपीराइट (c) सुनिल साहू
 * @वेबसाइट www.sunilbooks.com
 * 
 */

public class Message {

    // यह संदेश स्ट्रिंग है जिस पर WaiterThread और NotifierThread काम करते हैं
    private String msg;

    // एक विशेष स्ट्रिंग के साथ संदेश ऑब्जेक्ट को आरंभ करने के लिए कंस्ट्रक्टर
    public Message(String str) {
        this.msg = str;
    }

    // वर्तमान संदेश स्ट्रिंग लौटाने के लिए गेटर मेथड
    public String getMsg() {
        return msg;
    }

    // संदेश स्ट्रिंग को अपडेट करने के लिए सेटर मेथड
    public void setMsg(String str) {
        this.msg = str;
    }

}
```

### व्याख्या:
1. **`msg`**: यह एक प्राइवेट सदस्य है जो संदेश स्ट्रिंग को रखता है। `WaiterThread` और `NotifierThread` इस संदेश के साथ इंटरैक्ट करते हैं।
2. **`wait()`**: जब एक थ्रेड इस मेथड को संदेश ऑब्जेक्ट पर कॉल करता है, तो यह ऑब्जेक्ट पर जो लॉक इसे मिला है, उसे छोड़ देता है और एक अन्य थ्रेड से सूचना मिलने का इंतज़ार करता है ताकि वह जारी रह सके।
3. **`notify()`/`notifyAll()`**: NotifierThread इन मेथड्स का उपयोग प्रतीक्षारत थ्रेड्स को जगाने के लिए करता है। `notify()` एक थ्रेड को जगाता है, जबकि `notifyAll()` सभी प्रतीक्षारत थ्रेड्स को जगाता है।
